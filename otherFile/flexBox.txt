div элементы во flex элементе если им не прописать никаких размеров, то они будут занимать как можно меньше места как они могут, например по контенту внутри. flex элементы стремятся растянуться на 100%, если в одном из блоков нет контента и ширина не прописана, то соответственно этот элемент просто не появится, тогда следует прописать flex элементам ширину 100%, тогда этот элемент появится 

<div class="testingFlexBox">    
  <div>1</div>
  <div>2</div>
  <div>3</div>
  <div>4</div>
</div>

.testingFlexBox { 
  display: 
    flex;
    inline-flex; Строчные элементы, но по всем правилам flex-box
    justify-content: Выравнивание элементов по горизонтали 
    flex-start; Элементы вначале колонки
    flex-end; Элементы в конце колонки  
    center; В центре
    space-between; Первый и последний элемент максимально прижаты по краям, а отступы между элементами распределяются равномерно

    space-around; Отступы от краев половина от отступов между элементами
    space-evenly; Отступы одинаковые везде    

  align-items: Выравнивание по вертикале, но это свойство естественно будет работать если у родителя будет фиксированная высота
    flex-start; Элементы выравниваются по вертикале сверху
    center; По центру
    flex-end; В конце
    baseline; Выравниваются по их базовой линии 
    stretch; Элементы растягиваются на весь контейнер и это значение по умолчанию

  flex-direction: Направление элементов 
    row; Стандартное направление слева направо

    row-reverse; Наоборот с право на лево, и смотри если направление оси поменялось, то у свойства justify-content направление тоже поменяется, например его flex-start будет начинаться с права, а flex-end будет с слева 

    column; Элементы становятся вертикально, то и свойство justify-content и align-items тоже поменяется, justify-content будет отвечать за выравнивание по вертикали со значениями (space-around, space-between и т.д.), а align-items будет выравнивать по горизонтали

    column-reverse; Вертикально и в обратном порядке, и смотри если направление оси поменялось, то у свойства align-items направление тоже поменяется, например его flex-start будет начинаться снизу, а flex-end будет сверху 

    flex-wrap:  Перенос элементов на новую строку, если они не помещаются
      no-wrap; Стандартное значение, и если элементов много, то они начинают сжиматься чтоб поместится в одну линию
      wrap; Включить перенос
      wrap-reverse; Переносит в обратном порядке, то есть элементы стояли сверху и переносил элементы вниз, с этим значением будет элементы стоять снизу(если как бы стояло значение justify-content: flex-end) и переносить наверх

    flex-flow: Свойства flex-direction и flex-wrap используется так часто вместе, что было создано свойство flex-flow  
      row wrap;
      column nowrap; 

    align-content: Отвечает за расстояние между рядами, например если элементы не влезают в один ряд, прописываем свойство wrap, и элементы переносятся на новый ряд, и если высота фиксированная, то расстояние между рядами может быть слишком большое, вот тут нам на помощь идет align-content, и это свойство работает только если несколько рядов. Разница между align-items в том что, align-items регулирует элементы только если ряд один, но если несколько рядов он тоже выравнивает, но расстояние между рядами будет большое
      flex-start;
      flex-end;
      center;
      space-between;
      space-around;
      stretch;

    flex-grow: Коэффициент увеличения
      0; Значение по умолчанию
      1; Можно задать определенному элементу или нескольким элементам, и этот элемент расширится на все доступное пространство относительно других элементов. Например смотри, родитель будет например 600px в ширину, и в нем два элемента флексовых, прописываем обоим элементам flex-grow:1; и они растянулись на всю ширину родителя пополам по 300px, но если бы одному прописали flex-grow:1, а другому flex-grow:2, то 600/3=200, значит один элемент будет занимать 400px а другой 200px. Но нужно учитывать что эти элементы будут занимать в оставшемся пространстве, то есть если эти элементы будут фиксированной изначально шириной например width:200px, то эти элементы все равно расширятся на всю ширину родителя, но свои пропорции в 200px будут сохранять, а растянутся на оставшееся пространство. Но например если в эти элементы поместить много текста и даже не будет фиксированной ширины, хоть будут установленны значения flex-grow:1 и flex-grow:2, то эти элементы растянутся пополам, так как оставшегося пространства просто нет из-за текста

    flex-shrink: Коэффициент сжатия, элемент не может сжиматься меньше чем его flex-basis/width
      0; Элемент вообще не будет сжиматься
      1; Значение по умолчанию, элемент при уменьшении экрана будет уменьшаться
      2; Элемент уменьшаться будет в два раза больше
      Например так же два элемента, но если прописать без фиксированной ширины одному flex-shrink:1 и flex-shrink:2 другому, то второго элемента сразу сожмет больше чем первого, а прописав фиксированную ширину при уменьшении экрана будет видно как второй элемент уменьшается больше чем первый

    flex-basis: 200px; Базовая ширина, но может прийти философский вопрос, зачем flex-basis если можно прописать width. Базовое расстояние flex элемента 200px, во flex-direction:row это width:200, а в flex-direction:column это height:200px, flex-basis это размер вдоль главный оси, крч flex-basis зависит от оси на которой стоит элемент. Но это не запрещает использовать flex-basis вместе с width и height, но flex-basis сильнее чем width и height, то есть если значение width и height будет больше чем у flex-basis, то значение установится flex-basis. Но он не может перебить свойство как max и min width. А auto это значение по умолчанию

    flex: 0 1 auto;
    flex-grow: 0;
    flex-shrink: 1;
    flex-basis: auto;

    flex: none;
    flex-grow: 0;
    flex-shrink: 0;
    flex-basis: auto;

    flex: 2;
    flex-grow: 2;

    flex: 2 2;
    flex-grow: 2;
    flex-shrink: 2;

    flex: 1 30px;
    flex-grow: 1;
    flex-basis: 30px

    flex: 10em/30px/auto/50% Это все flex-basis

		gap: 10px; Будут отступы вокруг flex элементов, но у границ flex родителя отступов не будет
}

Приоритет flex элементов, приоритет идет слева на право, с лева самое меньшее число, с права самое большое
div:nth-child(1) {
  order: 1; У Элемента приоритет стал выше чем у остальных и встал в самый конец ряда, так как по дефолту значение установлено 0
}
div:nth-child(3) {
  order: -1; У последнего элемента приоритет стал самым низким, и он переместился в самое начало ряда
}
Html структура такие манипуляции никак не трогают
Так же можем для каждого элемента установить свой приоритет
div:nth-child(1) {
  order: 2;
}
div:nth-child(2) {
  order: 3;
}
div:nth-child(3) {
  order: 1;
}
И помни что flex-direction так же меняет значение 

div:nth-child(1) {
  align-self: Принимает все те же значения что и align-items, перемещаем не группу элементов, а определенные элементы,
  можно указать несколько сразу
    center;
    start;
    end;
    stretch;
    baseline;
    auto; Значение по умолчанию берет родительское значение align-items или stretch, если нет родителя
}







