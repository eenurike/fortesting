<div class="testingFlexBox">    
  <div>1</div>
  <div>2</div>
  <div>3</div>
  <div>4</div>
</div>

.testingFlexBox { 
  display: 
    flex;
    inline-flex; Строчные элементы, но по всем правилам flex-box
  justify-content: Выравнивание элементов по горизонтали 
    flex-start; Элементы вначале колонки
    flex-end; Элементы вконце колонки  
    center; В центре
    space-between; Первый и последний элемент максимально прижаты по краям, а отступы между элементами    распределяются равномерно

    space-around; Отступы от краев половина от отступов между элементами
    space-evenly; Отступы одинаковые везде    

  align-items: Выравнивание по вертикале, но это свойтсво естественно будет работать если у родителя будет фиксированаая высота
    flex-start; Элементы выравнятся по вертикале сверху
    center; По центру
    flex-end; В конце
    baseline; Выравнятся по их базовой линии 
    stretch; Элементы растягиваются на весь контенер и это значение по умолчанию

  flex-direction: Направление элементов 
    row; Стандартное направление слева направо

    row-reverse; Наоборот справо на лево, и смотри если направление оси поменялось, то у свойства justify-content направление тоже поменяется, например его flex-start будет начинаться с права, а flex-end будет с слева 

    column; Элементы становятся вертикально, то и свойство justify-content и align-items тоже поменятеся, justify-content будет отвечать за выравнивание по вертикали со значениями (space-around, space-between и т.д.), а align-items будет выравнивать по горизонтали

    column-reverse; Вертикально и в обратном порядке, и смотри если направление оси поменялось, то у свойства align-items направление тоже поменяется, например его flex-start будет начинаться снизу, а flex-end будет сверху 

    flex-wrap:  Перенос элементов на новую строку, если они не помещаются
      no-wrap; Стандорное значение, и если элементов много, то они начинают сжиматься чтоб поместится в одну линию
      wrap; Включить перенос
      wrap-reverse; Переносит в обратном порядке, то есть эементы стояли сверху и переносил элементы вниз, с этим значением будет элементы стоять снизу(если как бы стояло значение justify-content: flex-end) и переносить наверх

    flex-flow: Свойства flex-direction и flex-wrap используется так часто вместе, что было создано свойство flex-flow  
      row wrap;
      column nowrap; 

    align-content: Отвечает за растояние между рядами, например если элементы не влезают в один ряд, прописываем свойство wrap, и элементы переносятся на новый ряд, и если высота фиксированая, то растояние между рядами может быть слишком большое, вот тут нам на помощь идет align-content, и это свойство работает только если несколько рядов. Разница между align-items в том что, allign-items регулирует элементы только если ряд один, но если несколько рядов он тоже выравнивает, но растояние между рядами будет большое
      flex-start;
      flex-end;
      center;
      space-between;
      space-around;
      stretch;

    flex-grow: Коэфицент увеличения
      0; Значение по умолчанию
      1; По задать определенному элементу или нескольким элементам, и этот элемент расширится на все доступное пространство относительно других элементов. Например смотри родитель будет например 600px в ширину, и в нем два элемента флексовых, прописываем обоим элементам flex-grow:1; и они растянулись на всю ширину родителя пополам по 300px, но если бы одному прописали flex-grow:1, а другому flex-grow:2, то 600/3=200, значит один элемент будет занимать 400px а другой 200px. Но нужно учитывать что эти элементы будут занимать в оставшемся пространстве, то есть если эти элементы будут фиксированной изначально шириной непример width:200px, то эти элементы все равно расширятся на всю ширину родителя, но свои пропорции в 200px будут сохранять, а растянутся на оставшееся пространство. Но например в эти элементы поместить много текстаи даже не будет фиксированной ширины, хоть буду установленны значения flex-grow:1 и flex-grow:2, то эти элементы растянутся пополам, так как оставшегося пространства просто нет из-за текста

    flex-shrink: Коэфицент сжатия   
      0; Элемент вообще не будет сжиматься
      1; Значение по умолчанию, элемент при уменьшении экрана будет уменьшаться
      2; Элемент уменьшаться будет в два раза больше
      Например так же два элемента, но если прописать без фиксированной ширины одному flex-shrink:1 и flex-shrink:2 другому, то второго элемента сразу сожмет больше чем первого, а прописав фиксированную ширину при уменьшении экрана будет видно как второй элемент уменьшается больше чем первый

    flex-basis: 200px; Базовая ширина, но может прийти филосовский вопрос, зачем flex-basis если можно прописать width. Базовое растояние flex элемента 200px, во flex-direction:row это width:200, а в flex-direction:column это height:200px, flex-basis это размер вдоль главнй оси, крч flex-basis зависит от оси на которой стоит элемент. Но это не запрещает использовать flex-basis вместе с width и height, но flex-basis сильнее чем width и height, то есть если значение width и height будет больше чем у flex-basis, то значение установится flex-basis. Но он не может перебить свойсто как max и min width

    flex: 0 1 auto;
    flex-grow: 0;
    flex-shrink: 1;
    flex-basis: auto;

    flex: none;
    flex-grow: 0;
    flex-shrink: 0;
    flex-basis: auto;

    flex: 2;
    flex-grow: 2;

    flex: 2 2;
    flex-grow: 2;
    flex-shrink: 2;

    flex: 1 30px;
    flex-grow: 1;
    flex-basis: 30px

    flex: 10em/30px/auto/50% Это все flex-bais
}

Приоритет flex элементов, приоритет идет слева на право, с лева самое меньшее число, с права самое большое
div:nth-child(1) {
  order: 1; У Элемента приоритет стал выше чем у остальных и встал в самый конец ряда, так как подефолту значение установлено 0
}
div:nth-child(3) {
  order: -1; У последнего элемента приоритет стал самым низким, и он переместился в самое начало ряда
}
Html структура такие манипуляции никак не трогают
Так же можем для каждого элемента установить свой приоритет
div:nth-child(1) {
  order: 2;
}
div:nth-child(2) {
  order: 3;
}
div:nth-child(3) {
  order: 1;
}
И помни что flex-direction так же меняет значение 

div:nth-child(1) {
  align-self: Принимает все те же значения что и align-items, перемещаем не группу элементов, а определенные элементы,
  можно указать несколько сразу
    center;
    flex-start;
    flex-end;
    stretch;
    baseline;
    auto; Значение по умолчанию берет родительское значение align-items или stretch, если нет родителя
}


Например у нас есть три карточки с разным контентом, и эти карточки распределя
.card {
	flex-basis: 33%;

}



