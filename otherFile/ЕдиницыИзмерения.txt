Абсолютные единицы измерения - то-есть они не меняются типа px
	px используем тогда когда верстаем какие-то тонкие линии, какие-то границы и т.д. В других случаях лучше использовать другие единицы измерения, так как это адаптивный веб
Относительные единицы измерения - то есть они рассчитываются относительно чего-то 
rem и em - эти единицы измерения они зависят от font-size
	rem - рассчитывается от глобального размера шрифта
		html {
			font-size: 16px;
		}
		p {
			font-size: 1rem; то есть 16px (16 * 1)
			font-size: 1.5rem; то есть 24 (16 * 1.5)
				Или пользуйся онлайн конвертерами
		}
	em - так же зависит от font-size, но от ближайшего родителя	
		body {
			font-size: 14px;
		}
		header {
			font-size: 1em; то есть 14px
		}
		header h1 {
			font-size: 2em; то есть 28px
				Потому-что родитель у h1 это header, а у header размер шрифта 14px
		}
		А ЕСЛИ 
		body {
			font-size: 14px;
		}
		header {
			font-size: 2em; это 28px (14 * 2)
		}
		header h1 {
			font-size: 2em; это 56px (28 * 2)
		}
	Так же можно прописывать em и rem для блоков, отступов 
	.block {
		width: 12.5em;
		height: 12.5em;
		padding: 0.937em;
	}
	Смотри, при адаптивной верстке можешь использовать для шрифта clamp, но отступы в виде padding margin указывать в em, так как все равно em рассчитывается от родительского font-size

	% - рассчитываются тоже относительно чего-то
		body {
			width: 50%;
				То есть body будет занимать половину от окна браузера
		}
		header {
			width: 50%;
				Будет уже занимать половину от body, то есть еще меньше чем от окна браузера
		}

	.block {
		width: 500px;
		height: 700px;
	}
	.childBlock {
		width: 100px;
		height: 100px;
		margin-top: 100%;
		padding-top: 100%;
	}	
	Допустим блок в блоке, внутренний блок хочет оттолкнуться на 100% от верха, и по логике блок оттолкнется на 100%, но блок оттолкнется на 100% от ширины родителя то есть оттолкнется на 500px

	.childBlock {
		transform: translateX(100%);
	}
	Этот блок оттолкнется на 100% от себя, чтоб например блок переместить в левый край родителя нужно translateX(400%)

	.childBlock {
		font-size: 100%; Поведение точно такое же как с em
	}


	vw - рассчитывает размер относительно ширины viewport, область видимости экрана(например мой viewport 1450px)
		p.text {
			font-size: 1.37vw; 
				Это 20px относительно моего viewport, но смотри, если у чувака будет монитор очень широкий в 3000px, то соответственно размер шрифта будет намного больше чем 20px. В таком случае
			font-size: clamp(16px, 1.37vw, 32px);
				То есть ограничиваешь размер шрифта, 32px максимальный размер шрифта 
		}
			Так же и с margin, padding и т.д.

		.block {
			width: 100vw; Значит занимает полный экран по ширине, то есть 100%
		}

	vh - рассчитывает размер высоты относительно области просмотра по высоте 
		body {
			height: 100vh;
				Блок растянется на все окно по высоте экрана
		}	

	vmin vmax -	Работает относительно наименьшего и наибольшего из vw и vh
		.block {
			width: 90vmin; 
				Например у нас блок со значением width: 90vmin, и мой viewport 1536x726. И ширина блока будет рассчитываться от минимального значения, то есть высоты (726 х 90 / 100 = 653), и самое главное, когда экран будет уменьшаться и соответственно ширина блока тоже будет уменьшаться, но блок будет занимать ровно 90% экрана. Например экран 600х726, и минимальное значение это ширина (600 х 90 / 100 = 540), то есть блок будет рассчитываться относительно ширины и будет занимать 540px. Когда высота больше ширины, именно высота влияет на поведение блока, а когда ширина становится минимальным значением, то именно ширина начинает влиять на блок
			width: 90vmax;
				Например при размере экрана 1250х726, максимальное значение будет это значение ширины (1250 х 726 / 100 = 1125), то есть ширина блока 1125px, и блок занимает 90% экрана, и блок будет уменьшаться до тех пор пока ширина больше высоты, но когда высота это максимальное значение то блок перестает уменьшаться. Тут наоборот если ширина больше высоты, именно ширина влияет на поведение блока, а когда высота будет больше ширины, тогда высота начнет влиять на поведение блока
		} 
		.text {
			font-size: 3.2vmax;	(20px * 16px / 100%);
				Когда ширина будет больше высоты, тогда будет расти шрифт
		}
		С ограничениями пока только придумал с clamp()
		.text {
			font-size: clamp(20px, 3.2vmin, 32px);
				Если ширина будет больше высоты, тогда шрифт не будет увеличиваться а когда когда ширина становится меньше высоты тогда шрифт начинает уменьшаться, но уменьшается до 20px дальше останавливается 
			font-size: clamp(16px, 3.2vmax, 32px);
				Если ширина больше высоты, тогда шрифт начинает увеличиваться, но увеличится до 32px дальше остановится
		}

max-width min-width max-height min-height
max-width Не позволяет элементу увеличиться чем заданное значение в ширину
.block {
	width: 100%;
	max-width: 800px;
}
То-есть блок в 800px, а когда экран уменьшится меньше чем 800px, тогда блок займет все 100% экрана

min-width Не позволяет элементу уменьшиться чем на заданное значение в ширину
.block {
	width: 100%;
	max-width: 800px;
	min-width: 500px;
}
То-есть блок в 800px, а когда экран уменьшится меньше чем 800px, тогда блок займет все 100% экрана, а когда экран будет меньше чем 500px, то элемент прекратит уменьшаться. То есть меньше чем 500px блок уже не станет

max-height Не позволяет элементу стать больше чем заданное значение в высоту
.block {
	width: 100%;
	max-width: 800px;
	min-width: 500px;
	max-height: 700px;
}
Блок не увеличится больше чем на 700px в высоту

min-height Не позволяет элементу уменьшиться чем на заданное значение в высоту
.block {
	width: 100%;
	max-width: 800px;
	min-width: 500px;
	height: 100vh;
	max-height: 700px;
	min-height: 300px;
}

min() max() clamp()
Эти свойства работают, если одно из значений в процентах

min()
.block {
	width: 70%;
	max-width: 400px;
	height: 300px
	 Альтернатива этим значениям будет
	width: min(70%, 400px); 	/ min(20vw, 3rem)
	height: 300px
}	 
min ищет наименьшее значение, блок имеет ширину в 400px, но когда окно сжимается, то блок начинает уменьшаться в ширине но сохраняя пропорции в 70% от окна(родителя)

max() 
.block {
	width: 70%;
	min-width: 500px;
	height: 300px
	 Альтернатива этим значениям будет
	width: max(70%, 500px);
	height: 300px 
}
max ищет наибольшее значение, и тут наоборот блок занимает 70% от родителя, но когда сжимается экран доходит до 500px и он перестает сжиматься 

clamp()
.block {
	width: 80%;
	min-width: 400px;
	max-width: 600px;
	height: 300px;
	 Альтернатива этим значениям будет
	width: clamp(400px, 80%, 600px);
	height: 300px
}
Clamp это среднее между min и max. При 100% окне наш блок будет в 600px, а когда начнем уменьшать окно, блок тоже начнет уменьшаться но сохраняя пропорции в 80% от размера окна, потом когда он дойдет до 400px он перестанет уменьшаться 

Не забывай эти свойства работают со всем: шрифт, отступы(margin, padding), ширина, высота и т.д.
.block p {
	font-size: clamp(16px, 2vw, 2rem);
	color: white;
}
Тут обязательно нужно ставить единицу измерения vw, так как адаптивный шрифт должен отталкиваться от ширины экрана. В общем наименьший шрифт 16px и наибольший 32px(2rem - 32px), а в промежутке между этими значениями, шрифт будет увеличиваться и уменьшаться, в зависимости от экрана 

p {
	font-size: clamp(0.9375rem, 0.8493rem + 0.4412vw, 1.125rem); 15 / 18px
	margin-top: 0.55em; Тут отступ в 10px, а написал в em потомучто нужно чтоб отступ расчитывался от основного font size, а у этого конкретного элемента максимальный font-size 18px, поэтому em рассчитывается от него. А высчитали это так 10/18=0,55
}
А если бы в этом блоке не было rem, то em бы зависел от html то есть 16px

min-content, max-content, fit-content
Это не те вещи ты будешь каждый день, это именно те вещи которые помогают решать специфические проблемы
min-content - создает размер основываясь на содержимом, например 
h1 {
	font-size: 3rem;
	background-color: grey;
	width: min-content;
		Допустим в абзаце у нас два слово Nur Yelemesov. И ширина будет такой как самое длинное слово, то есть Yelemesov
} 

.text {
	background-color: red;
	width: max-content;
		Допустим у нас большая статья, с max-content вся эта статья будет в одну строку, то есть ширина основывается на всем максимальном тексте 
}

h1 {
	font-size: 3rem;
	background-color: grey;
	width: fit-content;
		Это смесь max-content и min-content, то есть у нас заголовок из двух слов, ширина ровно под эти два слова, но когда места не хватает при уменьшении экрана, и слова переносятся на новую строку. Полезность в том что не надо рассчитывать точную ширину для этого заголовка, а это свойство само определяет 
}

ch - рассчитывается относительно контента то есть количество шрифта
.text {
	max-width: 60ch
		То есть ширина будет в 60 символов максимум, дальше он не увеличится 
}

Разница между width: auto/100%
.block {
	width: 100%;
	margin-left: 200px;
		И появится горизонтальный скрол, так как мы указали что блок занимает 100% ширины родителя, и отталкиваем его на 200px
	width: auto;
		Тогда ширина блока будет занимать все пространство доступное ему, за исключением 200px слева, responsive все как надо и без горизонтального скрола 	
}


Для адаптива используй min-height и max-width. min-height не позволит высоте быть меньше заданного значения, но при добавлении контента блок будет увеличиваться. max-width не позволит увеличится ширине больше заданного, но позволит уменьшаться при сжатии экрана

Используй rem для шрифтов. em для полей, отступов и т.д. Все это можно использовать вместе с clamp с vw для резиновости  







