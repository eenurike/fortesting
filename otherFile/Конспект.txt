<a href="./index2.html" target="_black">Ссылка на другую страницу</a>
Смотри когда указываем ./ идет поиск в этой папке, target говорит чтоб открыть ссылку в новом окне

Когда указываешь размеры картинки, если задашь и высоту и ширину, то тебе придется четко угадать пропорции картинки, а когда задашь только width или height картинки, то размер картинки поменяется пропорционально, смотря от ситуации, когда тебе надо картинку впихнуть по ширине, то задаешь только width и высота сама подгонится, или когда картинку нужно разместить по высоте, то пишешь только height, а ширина сама подгонится

inherit значение будет наследоваться от родителя 

У картинок
img {
  width: 100%;
  max-width: 500px;
}
Смотри устанавливаем ширину в 100% это будет адаптивная картинка, то есть она будет всегда уменьшаться пропорционально,
но максимальная ширина картинки 500px, то-есть если размер экрана меньше 500px то картинка принимает ширину 100%

margin-left: auto;
margin-right: auto;
Если у элемента фиксированная ширина, не инлайновый элемент, а только если у элемента есть прописанная ширина тогда элемент встанет по центру
margin: 0 auto;
Сокращенный вариант
margin-left: auto;
Тогда этот элемент оттолкнется на максимум от левого края, то есть встанет в правом краю, так же и с margin-right только отталкиваться будет от правого края

margin: 1px 3px 5px 7px;
1px - верх
3px - права
5px - низ
7px - лево
margin: 1px 3px 5px;
1px - верх
3px - лево и правого
5px - низ
margin: 1px 3px;
1px - верх и низ
3px - лево и право
margin: 5px;
Отступ со всех сторон по 5px
С padding все тоже самое

Явления схлопывание вертикальных margin, это когда например у первого блока margin-bottom: 10px, а у второго блока margin-top: 30px, логично будет подумать отступ между первым и вторым блоком будет 40px, но тут работает понятие всхлопывание margin, то есть берется самое высокое значение, то есть отступ будет margin-top: 30px. У горизонтальных margin такого явления нет, как и у padding нет

Есть и отрицательные значения, но у padding нет, ну по логике вещей, как внутренний отступ вожмется в себя

https://dummyimage.com Заглушки на картинки

position: absolute;
Ты как бы берешь и выдераешь элемент с потока кода, и он болтается где хочет и никому мешать не буддет и он не может работать без своего брата position: relative; но если просто прописать absolute, не задавая родителю relative, то этот элемент будет позиционироваться относительно body, так как у body по дефолту прописано свойтво position: relative
position: sticky;
Это как position: fixed; но за одним исключением, fixed он как absolute выпадает из потока кода, и как бы становится поверх всех всех блоков, и ездит со скролом, а sticky он остается на своем месте не выпадая, а когда только начинаешь скролить он выпадает и становится fixed. Обязательное условие чтоб было какоето позиционирование например top: 0; и чтоб в html этот тег со свойством sticky не был единственным
<div class="sticky">bla</div>         .sticky {
<header></header>                       position: sticky;
<main></main>                           top: 0;
<footer></footer>                      }
То-есть теперь относительно header main footer наш блок sticky будет ездить

z-index: 1; 
Значение от меньшему к большему идет, меньшее значение слой самый первый самый снизу, большее значение слой выше, но лучше не делать z-index: 999; Лучше для себя прописать стандарт что от 1 до 6 слоя максимум

Псевдоэлемент ::before ::after 
Создается элемент после какого-то элемента 
.test::after {                    .test::after {   
  content: "";                      content: "";
  width: 100px;                     width: 100px;
  height: 100px;                    height: 100px;
  display: block;                   position: absolute;
  margin: и позиционируешь          top: и позиционируешь
  background-color: red;            left: и позиционируешь
}                                   background-color: red;    
Смотри чтоб элемент появился пишем либо display: block м позиционируем margin, или position: absolute и позиционируешь top,left,bottom,right, смотря от ситуации. В content: "nur" можем прописать чот-то или оставить пустой, чтоб элемент появился, можно комбинировать .test:nth-child(2)::after

Псевдоклассы :hover :nth-child(2) :nth-of-type(1) :first-child()

overflow: hidden (auto,scroll);
Например у нас фиксированная высота блока, а контента много, и контент вываливается за пределы блока, тогда прописываем overflow, hidden вырезает не поместившийся контент по размеру блока, auto/scroll добавляет скрол в этот блок 

box-sizing: border-box/content-box; Важное свойство которое прописывается вначале и всем файлам, крч это свойство занимается тем чтоб padding и border не вываливался наружу а как бы входил внутрь блока

transform:
translate(10px, 20px) Первое значение двигает по оси X, второе значение Y
translateY(10px) верх низ
translateX(10px) лево право
Но тут же приходит вопрос можно же это сделать margin, если будем перемещать элемент с margin, то и все элементы снизу тоже переместятся
rotate(180deg) повернет елемент на сколько нужно градусов
scale(1.1/0.9) увеличить и уменьшить элемент
skew(50deg, 90deg) первое значение X, второе Y наклонять элемент
Можно записать так 
transform: translateX(10px) rotate(30deg);

transition: all 1s ease 0s;
Это свойство отвечает за плавность
all - это для чего именно будем происходить анимация, можно прописать отдельно для определенного свойство плавность(border-radius, transform, color и т.д.)
1s - это время на анимацию
ease - это вид анимации, разные виды анимации можно посмотреть в инcпекторе кода, там прям наглядно показывается какие анимации и как они будут анимироваться, и можно даже свою анимацию там  же сделать, двигая ползунки
0s - это задержка на анимацию
И смотри чтоб плавность правильно работала, нужно transition прописывать на сам элемент, а не элемент с псевдокласс :hover
